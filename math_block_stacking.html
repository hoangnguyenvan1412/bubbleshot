<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Xếp Khối Toán Học – STEAM Math Mini Game</title>
  <style>
    :root {
      --bg: #0f172a;          /* slate-900 */
      --panel: #111827;       /* gray-900 */
      --accent: #22c55e;      /* green-500 */
      --accent-2: #60a5fa;    /* blue-400 */
      --danger: #ef4444;      /* red-500 */
      --text: #e5e7eb;        /* gray-200 */
      --muted: #9ca3af;       /* gray-400 */
      --tile: #1f2937;        /* gray-800 */
      --grid: #0b1220;        /* darker */
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--text); background: radial-gradient(1000px 600px at 10% 10%, #0b1a33 0%, var(--bg) 50%);
      display: grid; place-items: center; min-height: 100vh; padding: 24px;
    }
    .app {
      display: grid; grid-template-columns: 1fr auto; gap: 20px; width: min(100%, 1100px);
    }
    .board-wrap { background: linear-gradient(180deg, #0b1220, #0a0f1a); padding: 16px; border-radius: 18px; box-shadow: 0 10px 35px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.04); }
    .board { width: 360px; height: 720px; background: repeating-linear-gradient(0deg, var(--grid), var(--grid) 35px, #0f1b2e 35px, #0f1b2e 36px), repeating-linear-gradient(90deg, transparent, transparent 35px, #0f1b2e 35px, #0f1b2e 36px); position: relative; border-radius: 8px; overflow: hidden; }
    /* 10 x 20 grid, each cell 36px (incl. 1px grid line) -> board 360x720 */

    .hud {
      display: grid; gap: 12px; align-content: start; background: var(--panel); padding: 16px; border-radius: 18px; width: 320px;
      box-shadow: 0 10px 35px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05);
    }

    .stat { display: flex; justify-content: space-between; align-items: center; background: #0b1220; padding: 10px 12px; border-radius: 12px; color: var(--muted); }
    .stat b { color: var(--text); font-size: 18px; }

    .controls { display: grid; gap: 8px; }
    .controls input[type="number"], .controls input[type="text"] {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,.08); background: #0b1220; color: var(--text);
    }
    .controls .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; }

    button { cursor: pointer; background: var(--accent); border: none; color: #052e16; font-weight: 700; padding: 10px 14px; border-radius: 12px; box-shadow: 0 4px 0 #15803d; transition: transform .05s ease;
    }
    button.secondary { background: #1f2937; color: #e5e7eb; box-shadow: 0 4px 0 #111827; }
    button:active { transform: translateY(1px); box-shadow: 0 3px 0 rgba(0,0,0,.3); }

    .tile { position: absolute; width: 36px; height: 36px; display: grid; place-items: center; border-radius: 8px; font-weight: 800; font-size: 14px; letter-spacing: .4px; user-select: none; }
    .tile.active { outline: 2px solid rgba(255,255,255,.25); }
    .tile .eq { transform: translateY(-1px); }

    /* Colors for variety */
    .c1 { background: #1e293b; color: #93c5fd; box-shadow: inset 0 -3px 0 rgba(255,255,255,.08); }
    .c2 { background: #212c3e; color: #86efac; box-shadow: inset 0 -3px 0 rgba(255,255,255,.08); }
    .c3 { background: #243041; color: #fca5a5; box-shadow: inset 0 -3px 0 rgba(255,255,255,.08); }
    .c4 { background: #1f2a3a; color: #fde68a; box-shadow: inset 0 -3px 0 rgba(255,255,255,.08); }

    .legend { font-size: 13px; color: var(--muted); line-height: 1.4; }
    .kbd { display: inline-block; padding: 2px 6px; background: #0b1220; border: 1px solid rgba(255,255,255,.1); border-bottom-width: 2px; border-radius: 6px; font-weight: 700; color: #cbd5e1; }

    .next-wrap { display: grid; grid-template-columns: auto 1fr; gap: 12px; align-items: center; background: #0b1220; padding: 10px 12px; border-radius: 12px; }
    .nextbox { width: 72px; height: 72px; background: #0d1526; border-radius: 10px; display: grid; place-items: center; color: #93c5fd; font-weight: 800; }

    .banner { text-align: center; font-weight: 700; }
    .danger { color: var(--danger); }
    .ok { color: var(--accent-2); }
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="app">
    <div class="board-wrap">
      <div id="board" class="board" aria-label="Bàn chơi 10x20"></div>
    </div>

    <aside class="hud">
      <div class="stat"><span>Điểm</span><b id="score">0</b></div>
      <div class="stat"><span>Cấp độ</span><b id="level">1</b></div>
      <div class="stat"><span>Hàng đã xóa</span><b id="lines">0</b></div>

      <div class="next-wrap">
        <div class="nextbox" id="nextBox">?
        </div>
        <div>
          <div class="legend">Khối kế tiếp</div>
          <div id="nextEq" style="font-weight:800; font-size:18px; margin-top:4px;">—</div>
        </div>
      </div>

      <div class="controls">
        <div class="row">
          <input id="answer" type="number" placeholder="Nhập đáp án rồi Enter" inputmode="numeric" />
          <button id="submit" title="Trả lời (Enter)">OK</button>
        </div>
        <div style="display:flex; gap:8px;">
          <button id="start">Bắt đầu</button>
          <button id="restart" class="secondary">Chơi lại</button>
        </div>
        <div class="legend">
          <p class="banner" id="msg">Nhấn <span class="kbd">Bắt đầu</span> để chơi.</p>
          <p>
            Di chuyển: <span class="kbd">◀</span> <span class="kbd">▶</span> · Tăng tốc: <span class="kbd">▼</span> · Trả lời: gõ số rồi <span class="kbd">Enter</span>.<br/>
            Trả lời đúng <em>trước khi rơi chạm đáy</em> để khối biến mất. Nếu không, khối sẽ chất đống như Tetris.
          </p>
        </div>
      </div>
    </aside>
  </div>

  <script>
    // --- Game constants ---
    const COLS = 10; const ROWS = 20; const SIZE = 36; // px per cell
    const START_SPEED = 800; // ms per tick at level 1
    const SPEED_STEP = 60;   // speed-up per level (ms)
    const LINES_PER_LEVEL = 5;

    const boardEl = document.getElementById('board');
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const linesEl = document.getElementById('lines');
    const msgEl = document.getElementById('msg');
    const nextEqEl = document.getElementById('nextEq');
    const nextBoxEl = document.getElementById('nextBox');
    const startBtn = document.getElementById('start');
    const restartBtn = document.getElementById('restart');
    const answerInput = document.getElementById('answer');
    const submitBtn = document.getElementById('submit');

    // --- Game state ---
    let grid;           // 2D array ROWS x COLS, null | {text, answer, color}
    let active = null;  // {x, y, text, answer, color}
    let nextBlock = null;
    let timer = null;   // setInterval id
    let running = false;
    let score = 0; let level = 1; let lines = 0;

    function emptyGrid(){
      grid = Array.from({length: ROWS}, () => Array(COLS).fill(null));
    }

    function rnd(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }

    function makeEquation(lvl){
      // Generates an equation and integer answer suitable for the level
      // Level scaling: bigger numbers & more operations
      const ops = lvl < 2 ? ['+','-'] : lvl < 4 ? ['+','-','×'] : ['+','-','×','÷'];
      let a,b,op,ans;
      op = ops[rnd(0, ops.length-1)];
      if(op === '+') { a = rnd(0, 9 + lvl*3); b = rnd(0, 9 + lvl*3); ans = a + b; }
      else if(op === '-') { a = rnd(0, 9 + lvl*3); b = rnd(0, a); ans = a - b; }
      else if(op === '×') { a = rnd(0, 4 + lvl); b = rnd(0, 4 + lvl); ans = a * b; }
      else { // division -> ensure exact
        b = rnd(1, 5 + Math.floor(lvl/2)); ans = rnd(1, 5 + Math.floor(lvl/2)); a = b * ans; op = '÷';
      }
      return { text: `${a}${op}${b}`, answer: ans };
    }

    function newBlock(){
      const eq = nextBlock || makeEquation(level);
      const colors = ['c1','c2','c3','c4'];
      const color = colors[rnd(0, colors.length-1)];
      active = { x: Math.floor(COLS/2), y: 0, text: eq.text, answer: eq.answer, color };
      // Pre-generate next
      nextBlock = makeEquation(level);
      nextEqEl.textContent = nextBlock.text;
      nextBoxEl.textContent = nextBlock.text.replace(/[×÷]/g, (m)=> m==='×'?'x':'/');
      // If spawn collides -> game over
      if (collide(active.x, active.y)) {
        gameOver();
      }
    }

    function collide(nx, ny){
      // Check collision for active at (nx, ny)
      if (nx < 0 || nx >= COLS || ny < 0) return true;
      if (ny >= ROWS) return true;
      return grid[ny][nx] !== null;
    }

    function lockBlock(){
      if (!active) return;
      const {x,y,text,answer,color} = active;
      if (y >= 0 && y < ROWS && x >=0 && x < COLS) {
        grid[y][x] = { text, answer, color };
      }
      active = null;
      const cleared = clearFullRows();
      if (cleared > 0){
        score += cleared * 50; lines += cleared; maybeLevelUp();
        updateHUD();
        flashMsg(`Xóa ${cleared} hàng! +${cleared*50} điểm`, 'ok');
      }
      newBlock();
    }

    function clearFullRows(){
    //  let cleared = 0;
    //  for (let r = ROWS-1; r >= 0; r--){
    //    if (grid[r].every(cell => cell !== null)){
    //      // remove row r
    //      for (let y = r; y > 0; y--) grid[y] = grid[y-1].slice();
    //      grid[0] = Array(COLS).fill(null);
    //      cleared++; r++; // re-check same row index after shifting
    //    }
    //  }
    //  return cleared;
		return 0;
    }

    function maybeLevelUp(){
      const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
      if (newLevel !== level){
        level = newLevel;
        if (running){ restartTimer(); }
        flashMsg(`Lên cấp ${level}!`, 'ok');
      }
    }

    function restartTimer(){
      if (timer) clearInterval(timer);
      const speed = Math.max(150, START_SPEED - (level-1) * SPEED_STEP);
      timer = setInterval(tick, speed);
    }

    function tick(){
      if (!active) return;
      const ny = active.y + 1;
      if (collide(active.x, ny)){
        lockBlock();
      } else {
        active.y = ny;
        render();
      }
    }

    function move(dx){
      if (!active) return;
      const nx = active.x + dx;
      if (!collide(nx, active.y)){
        active.x = nx; render();
      }
    }

    function softDrop(){
      if (!active) return;
      const ny = active.y + 1;
      if (!collide(active.x, ny)){
        active.y = ny; render();
        score += 1; // tiny bonus for dropping
        updateHUD(false);
      }
    }

    function hardDrop(){
      if (!active) return;
      let steps = 0;
      while (!collide(active.x, active.y + 1)) { active.y++; steps++; }
      score += Math.max(0, steps - 1);
      render(); lockBlock();
    }

    function tryAnswer(){
      const val = Number(answerInput.value.trim());
      if (!Number.isFinite(val)) return;
      // If user has an active block and it matches
      if (active && val === active.answer){
        score += 10; updateHUD(); flashMsg('Đúng! +10', 'ok');
        active = null; // remove active block entirely
        newBlock();
      } else {
        // Maybe they clicked a landed tile to solve it
        const target = currentClickedCell; // {x,y}
        if (target){
          const cell = grid[target.y][target.x];
          if (cell && val === cell.answer){
            score += 5; grid[target.y][target.x] = null; updateHUD();
            applyGravity();
            flashMsg('Giải ô đúng! +5', 'ok');
          } else {
            flashMsg('Chưa đúng, thử lại nhé!', 'danger');
          }
        } else {
          flashMsg('Chưa đúng, thử lại nhé!', 'danger');
        }
      }
      answerInput.value = '';
      render();
    }

    function applyGravity(){
      // Simple gravity: pull down any floating tiles
      for (let x=0; x<COLS; x++){
        for (let y=ROWS-2; y>=0; y--){
          if (grid[y][x] && !grid[y+1][x]){
            let ny = y;
            while (ny+1 < ROWS && !grid[ny+1][x]) ny++;
            grid[ny][x] = grid[y][x];
            grid[y][x] = null;
          }
        }
      }
      // Optionally check for new full rows after gravity
      const cleared = clearFullRows();
      if (cleared){ score += cleared*50; lines += cleared; maybeLevelUp(); updateHUD(); }
    }

    function updateHUD(updateMsg = true){
      scoreEl.textContent = score;
      levelEl.textContent = level;
      linesEl.textContent = lines;
      if (updateMsg && running) msgEl.textContent = '';
    }

    function flashMsg(text, kind='ok'){
      msgEl.textContent = text; msgEl.className = `banner ${kind}`;
      setTimeout(()=>{ if (running) { msgEl.textContent = ''; } }, 1200);
    }

    function gameOver(){
      running = false; if (timer) clearInterval(timer);
      msgEl.innerHTML = '<span class="danger">Game Over!</span> Nhấn "Chơi lại" để thử nữa.';
    }

    function render(){
      // Clear board DOM
      boardEl.innerHTML = '';
      // Draw landed
      for (let y=0;y<ROWS;y++){
        for (let x=0;x<COLS;x++){
          const cell = grid[y][x];
          if (cell){
            const d = document.createElement('div');
            d.className = `tile ${cell.color}`;
            d.style.left = x*SIZE + 'px'; d.style.top = y*SIZE + 'px';
            d.innerHTML = `<span class="eq">${cell.text}</span>`;
            d.dataset.x = x; d.dataset.y = y;
            d.addEventListener('click', onTileClick);
            boardEl.appendChild(d);
          }
        }
      }
      // Draw active
      if (active){
        const d = document.createElement('div');
        d.className = `tile active ${active.color}`;
        d.style.left = active.x*SIZE + 'px'; d.style.top = active.y*SIZE + 'px';
        d.innerHTML = `<span class="eq">${active.text}</span>`;
        boardEl.appendChild(d);
      }
    }

    // --- Input handling ---
    let currentClickedCell = null; // {x,y} when user clicks a landed tile
    function onTileClick(e){
      const x = Number(e.currentTarget.dataset.x);
      const y = Number(e.currentTarget.dataset.y);
      currentClickedCell = {x,y};
      answerInput.focus();
      msgEl.textContent = 'Bạn đang giải ô ('+x+','+y+") – nhập đáp án và Enter";
    }

    window.addEventListener('keydown', (e)=>{
      if (!running) return;
      if (e.key === 'ArrowLeft'){ e.preventDefault(); move(-1); }
      else if (e.key === 'ArrowRight'){ e.preventDefault(); move(1); }
      else if (e.key === 'ArrowDown'){ e.preventDefault(); softDrop(); }
      else if (e.key === ' '){ e.preventDefault(); hardDrop(); }
      else if (e.key === 'Enter'){ e.preventDefault(); tryAnswer(); }
    });

    submitBtn.addEventListener('click', tryAnswer);

    startBtn.addEventListener('click', ()=>{
      if (running) return;
      startGame();
    });

    restartBtn.addEventListener('click', ()=>{
      stopGame(); startGame();
    });

    function startGame(){
      emptyGrid();
      score = 0; level = 1; lines = 0; running = true; currentClickedCell = null;
      updateHUD();
      nextBlock = makeEquation(level);
      nextEqEl.textContent = nextBlock.text; nextBoxEl.textContent = nextBlock.text;
      newBlock();
      render();
      restartTimer();
      answerInput.focus();
    }

    function stopGame(){
      running = false; if (timer) clearInterval(timer); timer = null;
    }

    // Initial render
    emptyGrid(); render();
  </script>
</body>
</html>
